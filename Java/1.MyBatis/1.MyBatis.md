### 自定义持久框架

>  自定义持久层框架本身：本质就是对JDBC代码进行的封装

1. 加载配置文件，根据配置文件（数据库配置信息和SQL配置信息）路径，加载配置文件成输入流，保存到内存中，创建Resources类，方法：InputStream  getResourcesAsStream()

2. 创建两个JavaBean(容器对象)，存放的就是对配置文件解析出来的内容

   * Configuration核心配置类，存放数据库配置信息
   * MappedStatement：映射配置类，存放SQL配置信息

3. 解析配置文件：Dom4j

   创建类SqlSessionFactoryBulider 方法：build(InputStram in);

   * 使用Dom4j解析配置文件，将解析出来的内容封装到容器对象中。
   * 创建SqlSessionFactory对象，生成SqlSession:会话对象（工厂模式）

4. 创建SqlSessionFactory接口和实现类，DefaultSqlSessionFactory，方法：openSession() 生产sqlSession

5. 创建SqlSession接口和实现类 DefaultSession，定义对数据库的crud操作，如 selectList()、selectOne()、update()、delete()

6. 创建Executor接口及实现类SimpleExecutor实现类，query(Configuration, MappedStatement,Object ... params)执行JDBC代码



### MyBatis 相关概念

#### 对象/关系型数据库映射（ORM）

ORM全称是 Object/Relation Mapping: 表示对象-关系映射的缩写

ORM 完成面向对象的编程语言到关系数据库的映射，当ORM框架完成映射后，程序员就可以利用面向对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势，ORM把关系数据库包装面向对象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。采用ORM框架后，应用程序不再直接访问底层数据库，而是以面向对象的方式来操作持久化对象，而ORM框架则将这些面向对象的操作转换成底层SQL操作。ORM框架实现的效果：把对持久化对象的保存、修改、删除等操作，转换为对数据库的操作

#### Mybatis简介

MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，他支持定制SQL、存储过程以及高级映射、MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集，MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO（Plain Old Java Objects，普通老式Java对象）为数据库中的记录。

#### MyBatis的优势

Mybatis是一个半自动化的持久层框架。对开发人员而言，核心SQL还是需要自己优化，SQL与Java编码分开，功能边界清晰，一个专注业务，一个专注数据。

**分析图如下**

![Mybatis的优势](图片\Mybatis的优势.png)

### Mybatis基本应用

#### 开发步骤

1. 添加Mybatis的坐标
2. 创建User数据表
3. 编写User实体类
4. 编写映射文件UserMapper.xml
5. 编写核心文件SqlMapConfig.xml
6. 编写测试类

#### 映射配置文件

![映射配置文件](图片\映射配置文件.png)

#### 核心配置文件

![核心配置文件](图片\核心配置文件.png)

#### 常用配置解析

##### envoironments标签

数据库的环境配置，支持多环境配置

![envoironments标签](图片/envoironments标签.png)

其中，事务管理器（transactionManager）类型有两种：

1. JDBC： 这个配置就是直接使用JDBC的提交和回滚设置，他依赖于从数据源得到的链接来管理事务作用域
2. MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个链接，而是让容器来管理事务的整个生命周期，比如JEE应用服务器的上下文。默认情况下他会关闭链接，然而一切容器并不希望这样，因此需要将closeConnection 属性设置为false 来组织他默认的关闭行为

其中数据源（DataSource）有三种

1. UNPOLLED
2. POOLED：这种数据源实现利用了池的概念，将JDBC链接对象组织起来
3. JNDI 这个数据源的实现是为了能在EJB或应用服务器这类容器中使用，容器可以集中或在外部配合数据源。然后放置一个JNDI上下文引用。

##### Mapper标签

改标签的作用是加载映射的，加载的方式有如下集中

1. 使用相对于类的路径资源引用，例如：

   ```xml
   <mapper resource="org/mybatis/builder/AuthorMapper.xml" />
   ```

2. 使用完全限定资源定位符（URL），例如：

   ```xml
   <mapper url="file:///var/mappers/AuthorMapper.xml"/>
   ```

3. 使用映射器接口实现类的完全限定类名，例如：

   ```xml
   <mapper class="org.mybatis.builder.AuthorMapper" />
   ```

4. 将包内的映射器接口实现全部注册为映射器，例如：

   ```xml
   <package name="org.mybatis.builder" />
   ```

#### Mybatis 相应API介绍

```java
//1.Resources工具类，配置文件的加载，把配置文件加载成字节输入流
InputStream resourceAsStream = Resources.getResourceAsStream("sqlMapConfig.xml");
//2.解析了配置文件，并创建了sqlSessionFactory工厂
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
//3.生产sqlSession
// 默认开启一个事务，但是该事务不会自动提交
//在进行增删改操作时，要手动提交事务
// 使用sqlSessionFactory.openSession(true); 为自动提交
SqlSession sqlSession = sqlSessionFactory.openSession();
//4.sqlSession调用方法：查询所有selectList  查询单个：selectOne 添加：insert  修改：update 删除：delete
List<User> users = sqlSession.selectList("user.findAll");
```

#### Mybatis开发方式

代理开发方式:采用MyBatis的代理开发方式实现DAO层的开发。Mapper接口开发方法只需程序猿编写Mapper接口（相当于Dao接口），由于MyBatis框架根据接口定义创建接口的动态代理对象，代理对象就是实现传统的Dao接口实现类的方法。

Mapper接口必须遵守一下规范:

1. Mapper.xml 文件中的namespace与mapper接口的全限定名相同
2. Mapper接口方法名和Mapper.xml中定义的每个statementId相同
3. Mapper接口方法的输入参数类型和Mapper.xml中定义的每个SQL的parameterType的类型相同
4. Mapper接口方法的输出参数类型和Mapper.xml中定义的每个SQLResultType类型相同

编写UserMapper接口

![UserMapper接口](图片/UserMapper接口.png)

### MyBatis 配置文件深入

#### SqlMapConfig.xml

##### 配置文件层级关系

![核心配置文件](图片\核心配置文件.png)

##### Mybaits 常用配置解析

###### envoironments标签

数据库的环境配置，支持多环境配置

![envoironments标签](图片/envoironments标签.png)

其中，事务管理器（transactionManager）类型有两种：

1. JDBC： 这个配置就是直接使用JDBC的提交和回滚设置，他依赖于从数据源得到的链接来管理事务作用域
2. MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个链接，而是让容器来管理事务的整个生命周期，比如JEE应用服务器的上下文。默认情况下他会关闭链接，然而一切容器并不希望这样，因此需要将closeConnection 属性设置为false 来组织他默认的关闭行为

其中数据源（DataSource）有三种

1. UNPOLLED
2. POOLED：这种数据源实现利用了池的概念，将JDBC链接对象组织起来
3. JNDI 这个数据源的实现是为了能在EJB或应用服务器这类容器中使用，容器可以集中或在外部配合数据源。然后放置一个JNDI上下文引用。

###### Mapper标签

改标签的作用是加载映射的，加载的方式有如下集中

1. 使用相对于类的路径资源引用，例如：

   ```xml
   <mapper resource="org/mybatis/builder/AuthorMapper.xml" />
   ```

2. 使用完全限定资源定位符（URL），例如：

   ```xml
   <mapper url="file:///var/mappers/AuthorMapper.xml"/>
   ```

3. 使用映射器接口实现类的完全限定类名，例如：

   ```xml
   <mapper class="org.mybatis.builder.AuthorMapper" />
   ```

4. 将包内的映射器接口实现全部注册为映射器，例如：

   ```xml
   <package name="org.mybatis.builder" />
   ```

######  Properties 标签

习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件

![properties标签.png](图片\properties标签.png)

###### typeAliase标签

类型别名是为Java类型设置一个短的别名，原来的类型配置名称如下

![typeAliases标签.png](图片/typeAliases标签.png)

配置typeLiases，为com.lagou.domain.User定义别名为user

![typeAliases标签2.png](图片/typeAliases标签2.png)

#### Mapper.xml

##### 动态SQL语句

```xml
<!-- where 标签 -->
<where>
    <!-- if标签 -->
    <if test = "id != null">
        and id = #{id}
    </if>
    <!-- foreach标签 -->
    <!-- collection:集合的名称，就是传进来的参数 -->
    <!-- open：语句以什么开始 -->
    <!-- end ：语句以什么结束-->
    <!-- item：集合的每一个元素 -->
    <!-- separator：元素之间用什么分割 -->
    <foreach  collection = "array" open = " id in (" end=")" item = "id" separator="," >
        #{id}
    </foreach>
</where>
<sql id = "allColumn">
    id,name
</sql>
<!-- SQL语句的抽取，然后进行引入 -->
<include refid="allColumn" ></include>
```

### MyBatis 复杂映射开发

####  一对一查询 association

查询所有的订单，以及每个订单所属用户信息

```java
public class User{
    private Integer id;
    private String username;
}
public class Order{
    private Integer id;
    private String orderTime;
    private Double total;
    private User user;
}
```

XML配置

```xml
<!-- 配置实体属性与数据库表的配置关系 -->
<resultMap id = "orderMap" type = "com.hhb.pojo.Order">
    <result property = "id"  column = "id"></result>
    <result property = "orderTime"  column = "orderTime"></result>
    <result property = "total"  column = "total"></result>
    <!--一对一的映射-->
	<association property = "user" javaType = "com.hhb.pojo.User">
    	<result property = "id" column = "uid"></result>
        <result property = "username" column = "username"></result>
    </association>
</resultMap>
```

SQL语句：

```sql
select u.*,o.username from orders o inner join user u where o.uid = o.id;
```

#### 一对多查询 collection

查询所有用户，已经每个用户下的所有订单

```java
public class User{
    private Integer id;
    private String username;
    private List<Order> list;
}
public class Order{
    private Integer id;
    private String orderTime;
    private Double total;
}

```

XML配置信息：

```xml
<!-- 配置实体属性与数据库表的配置关系 -->
<resultMap id = "userMap" type = "com.hhb.pojo.User">
    <id property = "id" column = "id"></id>
    <result property = "username" column = "username"></result>
    <!--一对多的映射-->
	<collection property = "list" ofType = "com.hhb.pojo.Order">
    	<id property = "id"  column = "oid"></id>
    	<result property = "orderTime"  column = "orderTime"></result>
    	<result property = "total"  column = "total"></result>
    </collection>
</resultMap>
```

SQL语句：

```sql
select 
	u.*,
	o.id as oid,
	o.orderTime,
	o.tolal 
from 
	user u 
left join 
	order o 
on u.id = o.uid;
```



#### 多对多查询

查询所有用户下的所有角色信息（一个用户可以有多个角色，一个角色可以属于多个用户）

```java
public class User{
    private Integer id;
    private String username;
    private List<Role> list;
}
public class Role{
    private int id;
    private roleName;
}
```

XML配置信息：

```xml
<!-- 配置实体属性与数据库表的配置关系 -->
<resultMap id = "userMap" type = "com.hhb.pojo.User">
    <id property = "id" column = "id"></id>
    <result property = "username" column = "username"></result>
    <!--一对多的映射-->
	<collection property = "list" ofType = "com.hhb.pojo.Role">
    	<id property = "id"  column = "rid"></id>
    	<result property = "roleName"  column = "roleName"></result>
    </collection>
</resultMap>
```

SQL信息：

```sql
select 
	u.*,
	r.id as rid,
    r.roleName
from
	user u
left join
	user_role_ref urf
on u.id = urf.uid
left join 
	role r
on urf.rid = r.id
```

### MyBatis注解开发

#### MyBatis的常用注解

1. @Insert： 新增

2. @Update：修改

   ```java
   @update("update user_info set username = #{userName} where id = #{id}")
   public void updateUser(User user);
   ```

3. @Delete：删除

   ```java
   @Delete("delete from user_info where id = #{id}")
   public void deleteUser(Integer id);
   ```

4. @Select：查询

   ```java
   @Select("select * from user_info")
   public List<User> selectUser();
   ```

5. @Result：实现结果集封装

6. @Results：可以与@Result一起使用，封装多个结果集

7. @One：实现一对一结果集封装

8. @Many：实现一对多结果集封装

#### MyBatis 的增删改查

新增：

```java
@Insert("insert into user_info values(#{id},#{userName})")
public void addUser(User user);
```

修改

```java
@update("update user_info set username = #{userName} where id = #{id}")
public void updateUser(User user);
```

删除

```java
@Delete("delete from user_info where id = #{id}")
public void deleteUser(Integer id);
```

查询

```java
@Select("select * from user_info")
public List<User> selectUser();
```

#### MyBatis的注解实现复杂映射开发

实现复杂关系映射之前，我们可以在映射文件中通过配置<resultMap>来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@Many注解组合完成复杂关系的配置

![复杂映射开发.png](图片/复杂映射开发.png)

#### 一对一查询（注解）